Index: sqlite3/ext/fts3/fts3_snippet.c
==================================================================
--- sqlite3/ext/fts3/fts3_snippet.c
+++ sqlite3/ext/fts3/fts3_snippet.c
@@ -128,14 +128,15 @@
 /*
 ** Allocate a two-slot MatchinfoBuffer object.
 */
 static MatchinfoBuffer *fts3MIBufferNew(int nElem, const char *zMatchinfo){
   MatchinfoBuffer *pRet;
-  int nByte = sizeof(u32) * (2*nElem + 1) + sizeof(MatchinfoBuffer);
-  int nStr = (int)strlen(zMatchinfo);
+  sqlite3_int64 nByte = sizeof(u32) * (2*(sqlite3_int64)nElem + 1)
+                           + sizeof(MatchinfoBuffer);
+  sqlite3_int64 nStr = strlen(zMatchinfo);
 
-  pRet = sqlite3_malloc(nByte + nStr+1);
+  pRet = sqlite3_malloc64(nByte + nStr+1);
   if( pRet ){
     memset(pRet, 0, nByte);
     pRet->aMatchinfo[0] = (u8*)(&pRet->aMatchinfo[1]) - (u8*)pRet;
     pRet->aMatchinfo[1+nElem] = pRet->aMatchinfo[0] + sizeof(u32)*(nElem+1);
     pRet->nElem = nElem;

Index: sqlite3/ext/fts3/fts3_test.c
==================================================================
--- sqlite3/ext/fts3/fts3_test.c
+++ sqlite3/ext/fts3/fts3_test.c
@@ -446,18 +446,18 @@
   if( p==pEnd ){
     rc = SQLITE_DONE;
   }else{
     /* Advance to the end of the token */
     const char *pToken = p;
-    int nToken;
+    sqlite3_int64 nToken;
     while( p<pEnd && testIsTokenChar(*p) ) p++;
-    nToken = (int)(p-pToken);
+    nToken = (sqlite3_int64)(p-pToken);
 
     /* Copy the token into the buffer */
     if( nToken>pCsr->nBuffer ){
       sqlite3_free(pCsr->aBuffer);
-      pCsr->aBuffer = sqlite3_malloc(nToken);
+      pCsr->aBuffer = sqlite3_malloc64(nToken);
     }
     if( pCsr->aBuffer==0 ){
       rc = SQLITE_NOMEM;
     }else{
       int i;

Index: sqlite3/ext/fts3/fts3_tokenize_vtab.c
==================================================================
--- sqlite3/ext/fts3/fts3_tokenize_vtab.c
+++ sqlite3/ext/fts3/fts3_tokenize_vtab.c
@@ -344,11 +344,11 @@
 
   fts3tokResetCursor(pCsr);
   if( idxNum==1 ){
     const char *zByte = (const char *)sqlite3_value_text(apVal[0]);
     int nByte = sqlite3_value_bytes(apVal[0]);
-    pCsr->zInput = sqlite3_malloc(nByte+1);
+    pCsr->zInput = sqlite3_malloc64(nByte+1);
     if( pCsr->zInput==0 ){
       rc = SQLITE_NOMEM;
     }else{
       memcpy(pCsr->zInput, zByte, nByte);
       pCsr->zInput[nByte] = 0;

Index: sqlite3/ext/fts3/fts3_tokenizer.c
==================================================================
--- sqlite3/ext/fts3/fts3_tokenizer.c
+++ sqlite3/ext/fts3/fts3_tokenizer.c
@@ -192,12 +192,12 @@
   }else{
     char const **aArg = 0;
     int iArg = 0;
     z = &z[n+1];
     while( z<zEnd && (NULL!=(z = (char *)sqlite3Fts3NextToken(z, &n))) ){
-      int nNew = sizeof(char *)*(iArg+1);
-      char const **aNew = (const char **)sqlite3_realloc((void *)aArg, nNew);
+      sqlite3_int64 nNew = sizeof(char *)*(iArg+1);
+      char const **aNew = (const char **)sqlite3_realloc64((void *)aArg, nNew);
       if( !aNew ){
         sqlite3_free(zCopy);
         sqlite3_free((void *)aArg);
         return SQLITE_NOMEM;
       }

Index: sqlite3/ext/fts3/fts3_write.c
==================================================================
--- sqlite3/ext/fts3/fts3_write.c
+++ sqlite3/ext/fts3/fts3_write.c
@@ -1748,12 +1748,13 @@
       nElem = 1;
     }
   }
 
   if( nElem>0 ){
-    int nByte = sizeof(Fts3SegReader) + (nElem+1)*sizeof(Fts3HashElem *);
-    pReader = (Fts3SegReader *)sqlite3_malloc(nByte);
+    sqlite3_int64 nByte;
+    nByte = sizeof(Fts3SegReader) + (nElem+1)*sizeof(Fts3HashElem *);
+    pReader = (Fts3SegReader *)sqlite3_malloc64(nByte);
     if( !pReader ){
       rc = SQLITE_NOMEM;
     }else{
       memset(pReader, 0, nByte);
       pReader->iIdx = 0x7FFFFFFF;
@@ -3361,11 +3362,11 @@
   int nBlob;               /* Number of bytes in the BLOB */
   sqlite3_stmt *pStmt;     /* Statement used to insert the encoding */
   int rc;                  /* Result code from subfunctions */
 
   if( *pRC ) return;
-  pBlob = sqlite3_malloc( 10*p->nColumn );
+  pBlob = sqlite3_malloc64( 10*(sqlite3_int64)p->nColumn );
   if( pBlob==0 ){
     *pRC = SQLITE_NOMEM;
     return;
   }
   fts3EncodeIntArray(p->nColumn, aSz, pBlob, &nBlob);
@@ -3411,11 +3412,11 @@
   int rc;                  /* Result code from subfunctions */
 
   const int nStat = p->nColumn+2;
 
   if( *pRC ) return;
-  a = sqlite3_malloc( (sizeof(u32)+10)*nStat );
+  a = sqlite3_malloc64( (sizeof(u32)+10)*(sqlite3_int64)nStat );
   if( a==0 ){
     *pRC = SQLITE_NOMEM;
     return;
   }
   pBlob = (char*)&a[nStat];
@@ -3532,12 +3533,12 @@
       rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
       sqlite3_free(zSql);
     }
 
     if( rc==SQLITE_OK ){
-      int nByte = sizeof(u32) * (p->nColumn+1)*3;
-      aSz = (u32 *)sqlite3_malloc(nByte);
+      sqlite3_int64 nByte = sizeof(u32) * ((sqlite3_int64)p->nColumn+1)*3;
+      aSz = (u32 *)sqlite3_malloc64(nByte);
       if( aSz==0 ){
         rc = SQLITE_NOMEM;
       }else{
         memset(aSz, 0, nByte);
         aSzIns = &aSz[p->nColumn+1];
@@ -3599,16 +3600,16 @@
   int nSeg,                       /* Number of segments to merge */
   Fts3MultiSegReader *pCsr        /* Cursor object to populate */
 ){
   int rc;                         /* Return Code */
   sqlite3_stmt *pStmt = 0;        /* Statement used to read %_segdir entry */  
-  int nByte;                      /* Bytes allocated at pCsr->apSegment[] */
+  sqlite3_int64 nByte;            /* Bytes allocated at pCsr->apSegment[] */
 
   /* Allocate space for the Fts3MultiSegReader.aCsr[] array */
   memset(pCsr, 0, sizeof(*pCsr));
   nByte = sizeof(Fts3SegReader *) * nSeg;
-  pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc(nByte);
+  pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc64(nByte);
 
   if( pCsr->apSegment==0 ){
     rc = SQLITE_NOMEM;
   }else{
     memset(pCsr->apSegment, 0, nByte);
@@ -5584,11 +5585,11 @@
     rc = SQLITE_CONSTRAINT;
     goto update_out;
   }
 
   /* Allocate space to hold the change in document sizes */
-  aSzDel = sqlite3_malloc( sizeof(aSzDel[0])*(p->nColumn+1)*2 );
+  aSzDel = sqlite3_malloc64(sizeof(aSzDel[0])*((sqlite3_int64)p->nColumn+1)*2);
   if( aSzDel==0 ){
     rc = SQLITE_NOMEM;
     goto update_out;
   }
   aSzIns = &aSzDel[p->nColumn+1];

Index: sqlite3/ext/fts5/fts5_tokenize.c
==================================================================
--- sqlite3/ext/fts5/fts5_tokenize.c
+++ sqlite3/ext/fts5/fts5_tokenize.c
@@ -367,11 +367,11 @@
       int i;
       memset(p, 0, sizeof(Unicode61Tokenizer));
 
       p->eRemoveDiacritic = FTS5_REMOVE_DIACRITICS_SIMPLE;
       p->nFold = 64;
-      p->aFold = sqlite3_malloc(p->nFold * sizeof(char));
+      p->aFold = sqlite3_malloc64(p->nFold * sizeof(char));
       if( p->aFold==0 ){
         rc = SQLITE_NOMEM;
       }
 
       /* Search for a "categories" argument */

Index: sqlite3/ext/rtree/geopoly.c
==================================================================
--- sqlite3/ext/rtree/geopoly.c
+++ sqlite3/ext/rtree/geopoly.c
@@ -267,11 +267,11 @@
      && (s.z++, geopolySkipSpace(&s)==0)
     ){
       GeoPoly *pOut;
       int x = 1;
       s.nVertex--;  /* Remove the redundant vertex at the end */
-      pOut = sqlite3_malloc64( GEOPOLY_SZ(s.nVertex) );
+      pOut = sqlite3_malloc64( GEOPOLY_SZ((sqlite3_int64)s.nVertex) );
       x = 1;
       if( pOut==0 ) goto parse_json_err;
       pOut->nVertex = s.nVertex;
       memcpy(pOut->a, s.a, s.nVertex*2*sizeof(GeoCoord));
       pOut->hdr[0] = *(unsigned char*)&x;
@@ -653,11 +653,11 @@
       else if( r>mxY ) mxY = (float)r;
     }
     if( pRc ) *pRc = SQLITE_OK;
     if( aCoord==0 ){
       geopolyBboxFill:
-      pOut = sqlite3_realloc(p, GEOPOLY_SZ(4));
+      pOut = sqlite3_realloc64(p, GEOPOLY_SZ(4));
       if( pOut==0 ){
         sqlite3_free(p);
         if( context ) sqlite3_result_error_nomem(context);
         if( pRc ) *pRc = SQLITE_NOMEM;
         return 0;
@@ -1049,13 +1049,13 @@
 
 /*
 ** Determine the overlap between two polygons
 */
 static int geopolyOverlap(GeoPoly *p1, GeoPoly *p2){
-  int nVertex = p1->nVertex + p2->nVertex + 2;
+  sqlite3_int64 nVertex = p1->nVertex + p2->nVertex + 2;
   GeoOverlap *p;
-  int nByte;
+  sqlite3_int64 nByte;
   GeoEvent *pThisEvent;
   double rX;
   int rc = 0;
   int needSort = 0;
   GeoSegment *pActive = 0;
@@ -1063,11 +1063,11 @@
   unsigned char aOverlap[4];
 
   nByte = sizeof(GeoEvent)*nVertex*2 
            + sizeof(GeoSegment)*nVertex 
            + sizeof(GeoOverlap);
-  p = sqlite3_malloc( nByte );
+  p = sqlite3_malloc64( nByte );
   if( p==0 ) return -1;
   p->aEvent = (GeoEvent*)&p[1];
   p->aSegment = (GeoSegment*)&p->aEvent[nVertex*2];
   p->nEvent = p->nSegment = 0;
   geopolyAddSegments(p, p1, 1);
@@ -1222,22 +1222,22 @@
   char **pzErr,                       /* OUT: Error message, if any */
   int isCreate                        /* True for xCreate, false for xConnect */
 ){
   int rc = SQLITE_OK;
   Rtree *pRtree;
-  int nDb;              /* Length of string argv[1] */
-  int nName;            /* Length of string argv[2] */
+  sqlite3_int64 nDb;              /* Length of string argv[1] */
+  sqlite3_int64 nName;            /* Length of string argv[2] */
   sqlite3_str *pSql;
   char *zSql;
   int ii;
 
   sqlite3_vtab_config(db, SQLITE_VTAB_CONSTRAINT_SUPPORT, 1);
 
   /* Allocate the sqlite3_vtab structure */
-  nDb = (int)strlen(argv[1]);
-  nName = (int)strlen(argv[2]);
-  pRtree = (Rtree *)sqlite3_malloc(sizeof(Rtree)+nDb+nName+2);
+  nDb = strlen(argv[1]);
+  nName = strlen(argv[2]);
+  pRtree = (Rtree *)sqlite3_malloc64(sizeof(Rtree)+nDb+nName+2);
   if( !pRtree ){
     return SQLITE_NOMEM;
   }
   memset(pRtree, 0, sizeof(Rtree)+nDb+nName+2);
   pRtree->nBusy = 1;

